codesample;labels;;
"    public JsonGenerator(LogIterator iter) {
	servers = new HashSet<Integer>();


	Pattern stateChangeP = Pattern.compile(""- (LOOKING|FOLLOWING|LEADING)"");
	Pattern newElectionP = Pattern.compile(""New election. My id =  (\\d+), Proposed zxid = (\\d+)"");
	Pattern receivedProposalP = Pattern.compile(""Notification: (\\d+) \\(n.leader\\), (\\d+) \\(n.zxid\\), (\\d+) \\(n.round\\), .+ \\(n.state\\), (\\d+) \\(n.sid\\), .+ \\(my state\\)"");
	Pattern exceptionP = Pattern.compile(""xception"");
	
	root = new JSONObject();
	Matcher m = null;
	JSONArray events = new JSONArray();
	root.put(""events"", events);
	
	long starttime = Long.MAX_VALUE;
	long endtime = 0;


	int leader = 0;
	long curEpoch = 0;
	boolean newEpoch = false;


	while (iter.hasNext()) {
	    LogEntry ent = iter.next();
	    
	    if (ent.getTimestamp() < starttime) {
		starttime = ent.getTimestamp();
	    }
	    if (ent.getTimestamp() > endtime) {
		endtime = ent.getTimestamp();
	    }
	    
	    if (ent.getType() == LogEntry.Type.TXN) {
		events.add(txnEntry((TransactionEntry)ent));
	    } else {
		Log4JEntry e = (Log4JEntry)ent;
		servers.add(e.getNode());
		
		if ((m = stateChangeP.matcher(e.getEntry())).find()) {
		    JSONObject stateChange = new JSONObject();
		    stateChange.put(""type"", ""stateChange"");
		    stateChange.put(""time"", e.getTimestamp());
		    stateChange.put(""server"", e.getNode());
		    stateChange.put(""state"", m.group(1));
		    events.add(stateChange);
		    
		    if (m.group(1).equals(""LEADING"")) {
			leader = e.getNode();
		    }
		} else if ((m = newElectionP.matcher(e.getEntry())).find()) {
		    Iterator<Integer> iterator = servers.iterator();
		    long zxid = Long.valueOf(m.group(2));
		    int count = (int)zxid;// & 0xFFFFFFFFL;
		    int epoch = (int)Long.rotateRight(zxid, 32);// >> 32;
		    
		    if (leader != 0 && epoch > curEpoch) {
			JSONObject stateChange = new JSONObject();
			stateChange.put(""type"", ""stateChange"");
			stateChange.put(""time"", e.getTimestamp());
			stateChange.put(""server"", leader);
			stateChange.put(""state"", ""INIT"");
			events.add(stateChange);
			leader = 0;
		    }
		    
		    while (iterator.hasNext()) {
			int dst = iterator.next();
			if (dst != e.getNode()) {
			    JSONObject msg = new JSONObject();
			    msg.put(""type"", ""postmessage"");
			    msg.put(""src"", e.getNode());
			    msg.put(""dst"", dst);
			    msg.put(""time"", e.getTimestamp());
			    msg.put(""zxid"", m.group(2));
			    msg.put(""count"", count);
			    msg.put(""epoch"", epoch);
			    
			    events.add(msg);
			}
		    }
		} else if ((m = receivedProposalP.matcher(e.getEntry())).find()) {
		    // Pattern.compile(""Notification: \\d+, (\\d+), (\\d+), \\d+, [^,]*, [^,]*, (\\d+)"");//, LOOKING, LOOKING, 2
		    int src = Integer.valueOf(m.group(4));
		    long zxid = Long.valueOf(m.group(2));
		    int dst = e.getNode();
		    long epoch2 = Long.valueOf(m.group(3));
		    
		    int count = (int)zxid;// & 0xFFFFFFFFL;
		    int epoch = (int)Long.rotateRight(zxid, 32);// >> 32;
		    
		    if (leader != 0 && epoch > curEpoch) {
			JSONObject stateChange = new JSONObject();
			stateChange.put(""type"", ""stateChange"");
			stateChange.put(""time"", e.getTimestamp());
			stateChange.put(""server"", leader);
			stateChange.put(""state"", ""INIT"");
			events.add(stateChange);
			leader = 0;
		    }
		    
		    if (src != dst) {
			JSONObject msg = new JSONObject();
			msg.put(""type"", ""delivermessage"");
			msg.put(""src"", src);
			msg.put(""dst"", dst);
			msg.put(""time"", e.getTimestamp());
			msg.put(""zxid"", zxid);
			msg.put(""epoch"", epoch);
			msg.put(""count"", count);
			msg.put(""epoch2"", epoch2);
			
			events.add(msg);
		    }
		} else if ((m = exceptionP.matcher(e.getEntry())).find()) {
		    JSONObject ex = new JSONObject();
		    ex.put(""type"", ""exception"");
		    ex.put(""server"", e.getNode());
		    ex.put(""time"", e.getTimestamp());
		    ex.put(""text"", e.getEntry());
		    events.add(ex);
		} 
	    }
	    JSONObject ex = new JSONObject();
	    ex.put(""type"", ""text"");
	    ex.put(""time"", ent.getTimestamp());
	    String txt = ent.toString();
	    ex.put(""text"", txt);
	    events.add(ex);
	}
	//	System.out.println(""pending messages: ""+pendingMessages.size());
	root.put(""starttime"", starttime);
	root.put(""endtime"", endtime);


	JSONArray serversarray = new JSONArray();
	root.put(""servers"", serversarray);
	
	Iterator<Integer> iterator = servers.iterator();
	while (iterator.hasNext()) {
	    serversarray.add(iterator.next());
	}
    }";1;;https://github.com/apache/zookeeper/blob/07c3aaf3d723fb3144c0aedc0c2b655325df70e9/zookeeper-contrib/zookeeper-contrib-loggraph/src/main/java/org/apache/zookeeper/graph/JsonGenerator.java/#L75-L213
"	private void createMenuEntries(Menu menu, DisplayItem parent,
			boolean trackDynamics) {
		if (menu == null)
			return;
		MenuItem[] menuItems = menu.getItems();


		Map findDynamics = new HashMap();
		DynamicContributionItem dynamicEntry = null;


		if (trackDynamics && menu.getParentItem() != null) {
			//Search for any dynamic menu entries which will be handled later
			Object data = menu.getParentItem().getData();
			if (data instanceof IContributionManager) {
				IContributionManager manager = (IContributionManager) data;
				IContributionItem[] items = manager.getItems();
				for (int i = 0; i < items.length; i++) {
					if (items[i].isDynamic()) {
						findDynamics.put(i > 0 ? items[i - 1] : null, items[i]);
					}
				}


				//If there is an item with no preceeding item, set it up to be
				//added first.
				if (findDynamics.containsKey(null)) {
					IContributionItem item = (IContributionItem) findDynamics
							.get(null);
					dynamicEntry = new DynamicContributionItem(item);
					parent.addChild(dynamicEntry);
				}
			}
		}


		for (int i = 0; i < menuItems.length; i++) {
			if (!menuItems[i].getText().equals("""")) { //$NON-NLS-1$
				IContributionItem contributionItem =
						(IContributionItem) menuItems[i].getData();
				if (dynamicEntry != null
						&& contributionItem.equals(dynamicEntry
								.getIContributionItem())) {
					//If the last item added is the item meant to go before the
					//given dynamic entry, add the dynamic entry so it is in the
					//correct order.
					dynamicEntry.addCurrentItem(menuItems[i]);
				} else {
					DisplayItem menuEntry = new DisplayItem(
							menuItems[i].getText(), contributionItem);


					Image image = menuItems[i].getImage();
					if (image != null) {
						menuEntry.setImageDescriptor(ImageDescriptor
								.createFromImage(image));
					}
					menuEntry.setActionSet((ActionSet) idToActionSet
							.get(getActionSetID(contributionItem)));
					parent.addChild(menuEntry);


					if (ActionFactory.NEW.getId()
							.equals(((IContributionItem) menuItems[i].getData())
									.getId())) {
						initializeNewWizardsMenu(menuEntry);
						wizards = menuEntry;
					} else if (SHORTCUT_CONTRIBUTION_ITEM_ID_OPEN_PERSPECTIVE
							.equals(((IContributionItem) menuItems[i].getData())
									.getId())) {
						initializePerspectivesMenu(menuEntry);
						perspectives = menuEntry;
					} else if (SHORTCUT_CONTRIBUTION_ITEM_ID_SHOW_VIEW
							.equals(((IContributionItem) menuItems[i].getData())
									.getId())) {
						initializeViewsMenu(menuEntry);
						views = menuEntry;
					} else {
						createMenuEntries(menuItems[i].getMenu(), menuEntry,
								trackDynamics);
					}


					if (menuEntry.getChildren().isEmpty()) {
						menuEntry
								.setCheckState(getMenuItemIsVisible(menuEntry));
					}


					if (image == null) {
						if (parent != null && parent.getParent() == null) {
							menuEntry.setImageDescriptor(menuImageDescriptor);
						} else if (menuEntry.getChildren().size() > 0) {
							menuEntry
									.setImageDescriptor(submenuImageDescriptor);
						}
					}
				}
				if (trackDynamics
						&& findDynamics.containsKey(menuItems[i].getData())) {
					IContributionItem item = (IContributionItem) findDynamics
							.get(menuItems[i].getData());
					dynamicEntry = new DynamicContributionItem(item);
					dynamicEntry
							.setCheckState(getMenuItemIsVisible(dynamicEntry));
					parent.addChild(dynamicEntry);
				}
			}
		}
	}";1;;https://github.com/eclipse/rap/blob/6295da95d01da6669c91bd4b058db9b89f35abaf/bundles/org.eclipse.rap.ui.workbench/Eclipse%20UI/org/eclipse/ui/internal/dialogs/CustomizePerspectiveDialog.java/#L2900-L3001
"                private boolean r_prelude() {
            int among_var;
            int v_1;
            int v_2;
            int v_3;
            int v_4;
            int v_5;
                    // (, line 34
                    // test, line 35
                    v_1 = cursor;
                    // repeat, line 35
                    replab0: while(true)
                    {
                        v_2 = cursor;
                        lab1: do {
                            // (, line 35
                            // [, line 36
                            bra = cursor;
                            // substring, line 36
                            among_var = find_among(a_0, 7);
                            if (among_var == 0)
                            {
                                break lab1;
                            }
                            // ], line 36
                            ket = cursor;
                            switch(among_var) {
                                case 0:
                                    break lab1;
                                case 1:
                                    // (, line 37
                                    // <-, line 37
                                    slice_from(""\u00E0"");
                                    break;
                                case 2:
                                    // (, line 38
                                    // <-, line 38
                                    slice_from(""\u00E8"");
                                    break;
                                case 3:
                                    // (, line 39
                                    // <-, line 39
                                    slice_from(""\u00EC"");
                                    break;
                                case 4:
                                    // (, line 40
                                    // <-, line 40
                                    slice_from(""\u00F2"");
                                    break;
                                case 5:
                                    // (, line 41
                                    // <-, line 41
                                    slice_from(""\u00F9"");
                                    break;
                                case 6:
                                    // (, line 42
                                    // <-, line 42
                                    slice_from(""qU"");
                                    break;
                                case 7:
                                    // (, line 43
                                    // next, line 43
                                    if (cursor >= limit)
                                    {
                                        break lab1;
                                    }
                                    cursor++;
                                    break;
                            }
                            continue replab0;
                        } while (false);
                        cursor = v_2;
                        break replab0;
                    }
                    cursor = v_1;
                    // repeat, line 46
                    replab2: while(true)
                    {
                        v_3 = cursor;
                        lab3: do {
                            // goto, line 46
                            golab4: while(true)
                            {
                                v_4 = cursor;
                                lab5: do {
                                    // (, line 46
                                    if (!(in_grouping(g_v, 97, 249)))
                                    {
                                        break lab5;
                                    }
                                    // [, line 47
                                    bra = cursor;
                                    // or, line 47
                                    lab6: do {
                                        v_5 = cursor;
                                        lab7: do {
                                            // (, line 47
                                            // literal, line 47
                                            if (!(eq_s(1, ""u"")))
                                            {
                                                break lab7;
                                            }
                                            // ], line 47
                                            ket = cursor;
                                            if (!(in_grouping(g_v, 97, 249)))
                                            {
                                                break lab7;
                                            }
                                            // <-, line 47
                                            slice_from(""U"");
                                            break lab6;
                                        } while (false);
                                        cursor = v_5;
                                        // (, line 48
                                        // literal, line 48
                                        if (!(eq_s(1, ""i"")))
                                        {
                                            break lab5;
                                        }
                                        // ], line 48
                                        ket = cursor;
                                        if (!(in_grouping(g_v, 97, 249)))
                                        {
                                            break lab5;
                                        }
                                        // <-, line 48
                                        slice_from(""I"");
                                    } while (false);
                                    cursor = v_4;
                                    break golab4;
                                } while (false);
                                cursor = v_4;
                                if (cursor >= limit)
                                {
                                    break lab3;
                                }
                                cursor++;
                            }
                            continue replab2;
                        } while (false);
                        cursor = v_3;
                        break replab2;
                    }
                    return true;
                }";1;;https://github.com/apache/lucene-solr/blob/bca22d58e2d126ec6d349d375d3ea028892104e1/lucene/analysis/common/src/java/org/tartarus/snowball/ext/ItalianStemmer.java/#L257-L401
"  public List<Feature> extract(JCas jCas, CollectionTextRelation cluster,
      IdentifiedAnnotation mention) throws AnalysisEngineProcessException {
    if(cache == null){
      throw new RuntimeException(""This extractor requires a cached Markable->ConllDependencyNode map to be set with setCache()"");
    }
    List<Feature> feats = new ArrayList<>();
    CounterMap<String> featCounts = new CounterMap<>();
    
    if(StringMatchingFeatureExtractor.isPronoun(mention)) return feats;
    
    String m = mention.getCoveredText();
    Set<String> mentionWords = contentWords(mention);
    Set<String> nonHeadMentionWords = new HashSet<>(mentionWords);
    ConllDependencyNode mentionHead = cache.get(mention);
    
    String mentionHeadString = null;
    if(mentionHead != null){
      mentionHeadString = mentionHead.getCoveredText().toLowerCase();
      nonHeadMentionWords.remove(mentionHeadString);


      int maxNonoverlap = 0;


      for(IdentifiedAnnotation member : new ListIterable<IdentifiedAnnotation>(cluster.getMembers())){
        if(member == null){
          System.err.println(""Something that shouldn't happen has happened"");
          continue;
        }else if(mention.getBegin() < member.getEnd()){
          // during training this might happen -- see a member of a cluster that
          // is actually subsequent to the candidate mention
          continue;
        }else if(StringMatchingFeatureExtractor.isPronoun(member)){
          continue;
        }


        String s = member.getCoveredText();
        Set<String> memberWords = contentWords(member);
        Set<String> nonHeadMemberWords = new HashSet<>(memberWords);
        ConllDependencyNode memberHead = cache.get(member);
        String memberHeadString = null;
        if(memberHead != null){
          memberHeadString = memberHead.getCoveredText().toLowerCase();
          nonHeadMemberWords.remove(memberHeadString);


          if(mentionHeadString.equals(memberHeadString)){


            if(m.equalsIgnoreCase(s)) featCounts.add(""MC_STRING_EXACT"");
            if(startMatch(m,s)) featCounts.add(""MC_STRING_START"");
            if(endMatch(m,s)) featCounts.add(""MC_STRING_END"");
            if(soonMatch(m,s)) featCounts.add(""MC_STRING_SOON"");
            if(wordOverlap(mentionWords, memberWords)) featCounts.add(""MC_OVERLAP"");
            if(wordSubstring(mentionWords, memberWords)) featCounts.add(""MC_SUB"");


            int nonHeadOverlap = wordNonOverlapCount(nonHeadMemberWords, nonHeadMentionWords);
            if(nonHeadOverlap > maxNonoverlap){
              maxNonoverlap = nonHeadOverlap;
            }
          }
        }
      }
      feats.add(new Feature(""MC_MAX_NONOVERLAP"", maxNonoverlap));
    }
    
    
    for(String featKey : featCounts.keySet()){
      // normalized
//      feats.add(new Feature(featKey, (double) featCounts.get(featKey) / clusterSize));
      // boolean
      feats.add(new Feature(featKey, true));
    }
    return feats;
  }";1;;https://github.com/apache/ctakes/blob/79be3ba2833857714bb301449f021cca36f373e6/ctakes-coreference/src/main/java/org/apache/ctakes/coreference/ae/features/cluster/MentionClusterStringFeaturesExtractor.java/#L35-L105
"    public List<Long> getOrderedLogFileIds() {
        File fileLogDir = new File(logDir);
        String[] logFileNames = null;
        List<Long> logFileIds = null;
        if (!fileLogDir.exists()) {
            LOGGER.log(Level.INFO, ""log dir "" + logDir + "" doesn't exist.  returning empty list"");
            return Collections.emptyList();
        }
        if (!fileLogDir.isDirectory()) {
            throw new IllegalStateException(""log dir "" + logDir + "" exists but it is not a directory"");
        }
        logFileNames = fileLogDir.list((dir, name) -> name.startsWith(logFilePrefix));
        if (logFileNames == null) {
            throw new IllegalStateException(""listing of log dir ("" + logDir + "") files returned null. ""
                    + ""Either an IO error occurred or the dir was just deleted by another process/thread"");
        }
        if (logFileNames.length == 0) {
            LOGGER.log(Level.INFO, ""the log dir ("" + logDir + "") is empty. returning empty list"");
            return Collections.emptyList();
        }
        logFileIds = new ArrayList<>();
        for (String fileName : logFileNames) {
            logFileIds.add(Long.parseLong(fileName.substring(logFilePrefix.length() + 1)));
        }
        logFileIds.sort(Long::compareTo);
        return logFileIds;
    }";1;;https://github.com/apache/asterixdb/blob/223d13a06c4a4a58408aeac19674ac1f36f5ff35/asterixdb/asterix-transactions/src/main/java/org/apache/asterix/transaction/management/service/logging/LogManager.java/#L440-L466
"   @Override
   public String sendMessage(final Map<String, String> headers,
                             final int type,
                             final String body,
                             boolean durable,
                             final String user,
                             final String password) throws Exception {
      if (AuditLogger.isEnabled()) {
         AuditLogger.sendMessage(this, null, headers, type, body, durable, user, ""****"");
      }
      try {
         return sendMessage(addressInfo.getName(), server, headers, type, body, durable, user, password);
      } catch (Exception e) {
         e.printStackTrace();
         throw new IllegalStateException(e.getMessage());
      }
   }";1;;https://github.com/apache/activemq-artemis/blob/5bd5c610195d6f4a3dd1ac28170727003f8a5a54/artemis-server/src/main/java/org/apache/activemq/artemis/core/management/impl/AddressControlImpl.java/#L347-L363
"  private static String normalizePath(String path) {
    // count the number of '/'s, to determine number of segments
    int index = -1;
    int pathlen = path.length();
    int size = 0;
    if (pathlen > 0 && path.charAt(0) != '/') {
      size++;
    }
    while ((index = path.indexOf('/', index + 1)) != -1) {
      if (index + 1 < pathlen && path.charAt(index + 1) != '/') {
        size++;
      }
    }


    String[] seglist = new String[size];
    boolean[] include = new boolean[size];


    // break the path into segments and store in the list
    int current = 0;
    int index2 = 0;
    index = (pathlen > 0 && path.charAt(0) == '/') ? 1 : 0;
    while ((index2 = path.indexOf('/', index + 1)) != -1) {
      seglist[current++] = path.substring(index, index2);
      index = index2 + 1;
    }


    // if current==size, then the last character was a slash
    // and there are no more segments
    if (current < size) {
      seglist[current] = path.substring(index);
    }


    // determine which segments get included in the normalized path
    for (int i = 0; i < size; i++) {
      include[i] = true;
      if (seglist[i].equals("".."")) { //$NON-NLS-1$
        int remove = i - 1;
        // search back to find a segment to remove, if possible
        while (remove > -1 && !include[remove]) {
          remove--;
        }
        // if we find a segment to remove, remove it and the ""..""
        // segment
        if (remove > -1 && !seglist[remove].equals("".."")) { //$NON-NLS-1$
          include[remove] = false;
          include[i] = false;
        }
      } else if (seglist[i].equals(""."")) { //$NON-NLS-1$
        include[i] = false;
      }
    }


    // put the path back together
    StringBuilder newpath = new StringBuilder();
    if (path.startsWith(""/"")) { //$NON-NLS-1$
      newpath.append('/');
    }


    for (int i = 0; i < seglist.length; i++) {
      if (include[i]) {
        newpath.append(seglist[i]);
        newpath.append('/');
      }
    }


    // if we used at least one segment and the path previously ended with
    // a slash and the last segment is still used, then delete the extra
    // trailing '/'
    if (!path.endsWith(""/"") && seglist.length > 0 //$NON-NLS-1$
        && include[seglist.length - 1]) {
      newpath.deleteCharAt(newpath.length() - 1);
    }


    String result = newpath.toString();


    // check for a ':' in the first segment if one exists,
    // prepend ""./"" to normalize
    index = result.indexOf(':');
    index2 = result.indexOf('/');
    if (index != -1 && (index < index2 || index2 == -1)) {
      newpath.insert(0, ""./""); //$NON-NLS-1$
      result = newpath.toString();
    }
    return result;
  }";1;;https://github.com/apache/shindig/blob/8f3c3d5c77f5324bad56a5a62da28657fe9112a0/java/common/src/main/java/org/apache/shindig/common/uri/Uri.java/#L205-L289
"        @Override
        public void addOptionValues(List<OptionValue> optionValues, Map<String, Object> context, Delegator delegator) {
            // first expand any conditions that need expanding based on the current context
            EntityCondition findCondition = null;
            if (UtilValidate.isNotEmpty(this.constraintList)) {
                List<EntityCondition> expandedConditionList = new LinkedList<>();
                for (EntityFinderUtil.Condition condition : constraintList) {
                    ModelEntity modelEntity = delegator.getModelEntity(this.entityName);
                    if (modelEntity == null) {
                        throw new IllegalArgumentException(""Error in entity-options: could not find entity ["" + this.entityName
                                + ""]"");
                    }
                    EntityCondition createdCondition = condition.createCondition(context, modelEntity,
                            delegator.getModelFieldTypeReader(modelEntity));
                    if (createdCondition != null) {
                        expandedConditionList.add(createdCondition);
                    }
                }
                findCondition = EntityCondition.makeCondition(expandedConditionList);
            }


            try {
                Locale locale = UtilMisc.ensureLocale(context.get(""locale""));
                ModelEntity modelEntity = delegator.getModelEntity(this.entityName);
                Boolean localizedOrderBy = UtilValidate.isNotEmpty(this.orderByList)
                        && ModelUtil.isPotentialLocalizedFields(modelEntity, this.orderByList);


                List<GenericValue> values = null;
                if (!localizedOrderBy) {
                    values = delegator.findList(this.entityName, findCondition, null, this.orderByList, null, this.cache);
                } else {
                    //if entity has localized label
                    values = delegator.findList(this.entityName, findCondition, null, null, null, this.cache);
                    values = EntityUtil.localizedOrderBy(values, this.orderByList, locale);
                }


                // filter-by-date if requested
                if (""true"".equals(this.filterByDate)) {
                    values = EntityUtil.filterByDate(values, true);
                } else if (!""false"".equals(this.filterByDate)) {
                    // not explicitly true or false, check to see if has fromDate and thruDate, if so do the filter
                    if (modelEntity != null && modelEntity.isField(""fromDate"") && modelEntity.isField(""thruDate"")) {
                        values = EntityUtil.filterByDate(values, true);
                    }
                }


                for (GenericValue value : values) {
                    // add key and description with string expansion, ie expanding ${} stuff, passing locale explicitly to expand value string because it won't be found in the Entity
                    MapStack<String> localContext = MapStack.create(context);
                    // Rendering code might try to modify the GenericEntity instance,
                    // so we make a copy of it.
                    Map<String, Object> genericEntityClone = UtilGenerics.cast(value.clone());
                    localContext.push(genericEntityClone);


                    // expand with the new localContext, which is locale aware
                    String optionDesc = this.description.expandString(localContext, locale);


                    Object keyFieldObject = value.get(this.getKeyFieldName());
                    if (keyFieldObject == null) {
                        throw new IllegalArgumentException(
                                ""The entity-options identifier (from key-name attribute, or default to the field name) [""
                                        + this.getKeyFieldName() + ""], may not be a valid key field name for the entity [""
                                        + this.entityName + ""]."");
                    }
                    String keyFieldValue = keyFieldObject.toString();
                    optionValues.add(new OptionValue(keyFieldValue, optionDesc));
                }
            } catch (GenericEntityException e) {
                Debug.logError(e, ""Error getting entity options in form"", module);
            }
        }";1;;https://github.com/apache/ofbiz-framework/blob/b1304439219bb04c396f5d000bec9c5fbb194b59/framework/widget/src/main/java/org/apache/ofbiz/widget/model/ModelFormField.java/#L1962-L2032
"    @SuppressWarnings(""try"")
    private void doRun(Map<Method, CEntryPointData> entryPoints, Method mainEntryPoint,
                    JavaMainSupport javaMainSupport, String imageName, AbstractBootImage.NativeImageKind k,
                    SubstitutionProcessor harnessSubstitutions,
                    ForkJoinPool compilationExecutor, ForkJoinPool analysisExecutor) {
        List<HostedMethod> hostedEntryPoints = new ArrayList<>();


        OptionValues options = HostedOptionValues.singleton();
        SnippetReflectionProvider originalSnippetReflection = GraalAccess.getOriginalSnippetReflection();
        try (DebugContext debug = DebugContext.create(options, new GraalDebugHandlersFactory(originalSnippetReflection))) {
            setupNativeImage(imageName, options, entryPoints, javaMainSupport, harnessSubstitutions, analysisExecutor, originalSnippetReflection, debug);


            boolean returnAfterAnalysis = runPointsToAnalysis(imageName, options, debug);
            if (returnAfterAnalysis) {
                return;
            }


            NativeImageHeap heap;
            HostedMethod mainEntryPointHostedStub;
            HostedMetaAccess hMetaAccess;
            SharedRuntimeConfigurationBuilder runtime;
            try (StopTimer t = new Timer(imageName, ""universe"").start()) {
                hUniverse = new HostedUniverse(bigbang);
                hMetaAccess = new HostedMetaAccess(hUniverse, bigbang.getMetaAccess());


                new UniverseBuilder(aUniverse, bigbang.getMetaAccess(), hUniverse, hMetaAccess, HostedConfiguration.instance().createStaticAnalysisResultsBuilder(bigbang, hUniverse),
                                bigbang.getUnsupportedFeatures()).build(debug);


                runtime = new HostedRuntimeConfigurationBuilder(options, bigbang.getHostVM(), hUniverse, hMetaAccess, bigbang.getProviders()).build();
                registerGraphBuilderPlugins(featureHandler, runtime.getRuntimeConfig(), (HostedProviders) runtime.getRuntimeConfig().getProviders(), bigbang.getMetaAccess(), aUniverse,
                                hMetaAccess, hUniverse,
                                nativeLibraries, loader, false, true, bigbang.getAnnotationSubstitutionProcessor(), new SubstrateClassInitializationPlugin((SVMHost) aUniverse.hostVM()),
                                bigbang.getHostVM().getClassInitializationSupport());


                if (NativeImageOptions.PrintUniverse.getValue()) {
                    printTypes();
                }


                /* Find the entry point methods in the hosted world. */
                for (AnalysisMethod m : aUniverse.getMethods()) {
                    if (m.isEntryPoint()) {
                        HostedMethod found = hUniverse.lookup(m);
                        assert found != null;
                        hostedEntryPoints.add(found);
                    }
                }
                /* Find main entry point */
                if (mainEntryPoint != null) {
                    AnalysisMethod analysisStub = CEntryPointCallStubSupport.singleton().getStubForMethod(mainEntryPoint);
                    mainEntryPointHostedStub = (HostedMethod) hMetaAccess.getUniverse().lookup(analysisStub);
                    assert hostedEntryPoints.contains(mainEntryPointHostedStub);
                } else {
                    mainEntryPointHostedStub = null;
                }
                if (hostedEntryPoints.size() == 0) {
                    throw UserError.abort(""Warning: no entry points found, i.e., no method annotated with @"" + CEntryPoint.class.getSimpleName());
                }


                heap = new NativeImageHeap(aUniverse, hUniverse, hMetaAccess);


                BeforeCompilationAccessImpl config = new BeforeCompilationAccessImpl(featureHandler, loader, aUniverse, hUniverse, hMetaAccess, heap, debug);
                featureHandler.forEachFeature(feature -> feature.beforeCompilation(config));


                bigbang.getUnsupportedFeatures().report(bigbang);
            } catch (UnsupportedFeatureException ufe) {
                throw UserError.abort(ufe.getMessage());
            }


            recordMethodsWithStackValues();
            recordRestrictHeapAccessCallees(aUniverse.getMethods());


            /*
             * After this point, all TypeFlow (and therefore also TypeState) objects are unreachable
             * and can be garbage collected. This is important to keep the overall memory footprint
             * low. However, this also means we no longer have complete call chain information. Only
             * the summarized information stored in the StaticAnalysisResult objects is available
             * after this point.
             */
            bigbang.cleanupAfterAnalysis();


            NativeImageCodeCache codeCache;
            CompileQueue compileQueue;
            try (StopTimer t = new Timer(imageName, ""compile"").start()) {
                compileQueue = HostedConfiguration.instance().createCompileQueue(debug, featureHandler, hUniverse, runtime, DeoptTester.enabled(), bigbang.getProviders().getSnippetReflection(),
                                compilationExecutor);
                compileQueue.finish(debug);


                /* release memory taken by graphs for the image writing */
                hUniverse.getMethods().forEach(HostedMethod::clear);


                codeCache = NativeImageCodeCacheFactory.get().newCodeCache(compileQueue, heap);
                codeCache.layoutConstants();
                codeCache.layoutMethods(debug, imageName);


                AfterCompilationAccessImpl config = new AfterCompilationAccessImpl(featureHandler, loader, aUniverse, hUniverse, hMetaAccess, heap, debug);
                featureHandler.forEachFeature(feature -> feature.afterCompilation(config));
            }


            try (Indent indent = debug.logAndIndent(""create native image"")) {
                try (DebugContext.Scope buildScope = debug.scope(""CreateBootImage"")) {
                    try (StopTimer t = new Timer(imageName, ""image"").start()) {


                        // Start building the model of the native image heap.
                        heap.addInitialObjects();
                        // Then build the model of the code cache, which can
                        // add objects to the native image heap.
                        codeCache.addConstantsToHeap();
                        // Finish building the model of the native image heap.
                        heap.addTrailingObjects();


                        AfterHeapLayoutAccessImpl config = new AfterHeapLayoutAccessImpl(featureHandler, loader, hMetaAccess, debug);
                        featureHandler.forEachFeature(feature -> feature.afterHeapLayout(config));


                        this.image = AbstractBootImage.create(k, hUniverse, hMetaAccess, nativeLibraries, heap, codeCache, hostedEntryPoints, mainEntryPointHostedStub, loader.getClassLoader());
                        image.build(debug);
                        if (NativeImageOptions.PrintUniverse.getValue()) {
                            /*
                             * This debug output must be printed _after_ and not _during_ image
                             * building, because it adds some PrintStream objects to static fields,
                             * which disrupts the heap.
                             */
                            codeCache.printCompilationResults();
                        }
                    }
                }
            }


            BeforeImageWriteAccessImpl beforeConfig = new BeforeImageWriteAccessImpl(featureHandler, loader, imageName, image,
                            runtime.getRuntimeConfig(), aUniverse, hUniverse, optionProvider, hMetaAccess, debug);
            featureHandler.forEachFeature(feature -> feature.beforeImageWrite(beforeConfig));


            try (StopTimer t = new Timer(imageName, ""write"").start()) {
                /*
                 * This will write the debug info too -- i.e. we may be writing more than one file,
                 * if the debug info is in a separate file. We need to push writing the file to the
                 * image implementation, because whether the debug info and image share a file or
                 * not is an implementation detail of the image.
                 */
                Path tmpDir = tempDirectory();
                Path imagePath = image.write(debug, generatedFiles(HostedOptionValues.singleton()), tmpDir, imageName, beforeConfig).getOutputFile();


                AfterImageWriteAccessImpl afterConfig = new AfterImageWriteAccessImpl(featureHandler, loader, hUniverse, imagePath, tmpDir, image.getBootImageKind(), debug);
                featureHandler.forEachFeature(feature -> feature.afterImageWrite(afterConfig));
            }
        }
    }";1;;https://github.com/oracle/graal/blob/4deb681aaaa79c248115037fc8e399c9876619fd/substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/NativeImageGenerator.java/#L487-L632
"	public static Control createCustomAreaWithLink(final Composite parent, final Dialog dialog, final Binary binary) {
		final String binaryLabel = binary.getLabel();
		final String prefix = ""The requested operation cannot be performed due to invalid '"" + binaryLabel
				+ ""' settings. Check your '"" + binaryLabel
				+ ""' configuration and preferences under the corresponding "";
		final String link = ""preference page"";
		final String suffix = ""."";
		final String text = prefix + link + suffix;


		final Composite control = new Composite(parent, NONE);
		control.setLayout(GridLayoutFactory.fillDefaults().create());
		final GridData gridData = GridDataFactory.fillDefaults().align(LEFT, TOP).grab(true, true).create();
		control.setLayoutData(gridData);


		final StyleRange style = new StyleRange();
		style.underline = true;
		style.underlineStyle = UNDERLINE_LINK;


		final StyledText styledText = new StyledText(control, MULTI | READ_ONLY | WRAP);
		styledText.setWordWrap(true);
		styledText.setJustify(true);
		styledText.setText(text);
		final GridData textGridData = GridDataFactory.fillDefaults().align(FILL, FILL).grab(true, true).create();
		textGridData.widthHint = TEXT_WIDTH_HINT;
		textGridData.heightHint = TEXT_HEIGHT_HINT;
		styledText.setLayoutData(textGridData);


		styledText.setEditable(false);
		styledText.setBackground(UIUtils.getSystemColor(COLOR_WIDGET_BACKGROUND));
		final int[] ranges = { text.indexOf(link), link.length() };
		final StyleRange[] styles = { style };
		styledText.setStyleRanges(ranges, styles);


		styledText.addMouseListener(new MouseAdapter() {


			@Override
			public void mouseDown(final MouseEvent event) {
				try {
					final int offset = styledText.getOffsetAtPoint(new Point(event.x, event.y));
					final StyleRange actualStyle = offset >= 0 ? styledText.getStyleRangeAtOffset(offset) : null;
					if (null != actualStyle && actualStyle.underline
							&& UNDERLINE_LINK == actualStyle.underlineStyle) {


						dialog.close();
						final PreferenceDialog preferenceDialog = createPreferenceDialogOn(
								UIUtils.getShell(),
								BinariesPreferencePage.ID,
								FILTER_IDS,
								null);


						if (null != preferenceDialog) {
							preferenceDialog.open();
						}


					}
				} catch (final IllegalArgumentException e) {
					// We are not over the actual text.
				}
			}


		});


		return control;
	}";1;;https://github.com/eclipse/n4js/blob/f715912fce0352ab574ff878086f77d17a78c908/plugins/org.eclipse.n4js.ui/src/org/eclipse/n4js/ui/binaries/IllegalBinaryStateDialog.java/#L97-L160
"/* HelloWorld.java
 */

public class HelloWorld
{
	public static void main(String[] args) {
		System.out.println(""Hello World!"");
	}
}";0;;https://www.cs.utexas.edu/~scottm/cs307/javacode/codeSamples/
"public static void go()
	{	Rectangle r1 = new Rectangle(0,0,5,5);
		System.out.println(""In method go. r1 "" + r1 + ""\n"");
		// could have been 
		//System.out.prinltn(""r1"" + r1.toString());
		r1.setSize(10, 15);
		System.out.println(""In method go. r1 "" + r1 + ""\n"");
		alterPointee(r1);
		System.out.println(""In method go. r1 "" + r1 + ""\n"");
		
		alterPointer(r1);
		System.out.println(""In method go. r1 "" + r1 + ""\n"");
	}
	";0;;
"public static void main(String[] args) {
        
        int first = 10;
        int second = 20;

        System.out.println(""Enter two numbers: "" + first + "" "" + second);
        int sum = first + second;

        System.out.println(""The sum is: "" + sum);
    }";0;;
"public static boolean[] getPrimes(int max) {
		boolean[] result = new boolean[max + 1];
		for(int i = 2; i < result.length; i++)
			result[i] = true;
		final double LIMIT = Math.sqrt(max);
		for(int i = 2; i <= LIMIT; i++) {
			if(result[i]) {
				// cross out all multiples;
				int index = 2 * i;
				while(index < result.length){
					result[index] = false;
					 index += i;
				}
			}
		}
		return result;
	}";0;;
"public static void printTest(int num, int expectedFactors) {
		Stopwatch st = new Stopwatch();
		st.start();
		int actualFactors = numFactors(num);
		st.stop();
		System.out.println(""Testing "" + num + "" expect "" + expectedFactors + "", "" +
				""actual "" + actualFactors);
		if(actualFactors == expectedFactors)
			System.out.println(""PASSED"");
		else
			System.out.println(""FAILED"");
		System.out.println(st.time());
	}";0;;
"public static boolean isPrime(int num) {
		assert num >= 2 : ""failed precondition. num must be >= 2. num: "" + num;
		final double LIMIT = Math.sqrt(num);
		boolean isPrime = (num == 2) ? true : num % 2 != 0;
		int div = 3;
		while(div <= LIMIT && isPrime) {
			isPrime = num % div != 0;
			div += 2;
		}
		return isPrime;
	}";0;;
"private long getMessageCount(final DurabilityType durability) {
      List<QueueControl> queues = getQueues(durability);
      long count = 0;
      for (QueueControl queue : queues) {
         count += queue.getMessageCount();
      }
      return count;
   }";0;;
"public String[] getRoutingTypes() {
      if (AuditLogger.isEnabled()) {
         AuditLogger.getRoutingTypes(this.addressInfo);
      }
      EnumSet<RoutingType> routingTypes = addressInfo.getRoutingTypes();
      String[] result = new String[routingTypes.size()];
      int i = 0;
      for (RoutingType routingType : routingTypes) {
         result[i++] = routingType.toString();
      }
      return result;
   }";0;;
"public static void main(String[]args)
    {
    	//For capturing user input
        Scanner scanner = new Scanner(System.in);
        System.out.println(""Enter the String for check:"");
        String string = scanner.nextLine();
        /* If function returns true then the string is
         * palindrome else not
         */
        if(isPal(string))
            System.out.println(string + "" is a palindrome"");
        else
            System.out.println(string + "" is not a palindrome"");
    }";0;;
"public static void main(String a[]){
    Details obj = new Details();
    System.out.println(""String: BeginnersBook.com"");
    System.out.println(""-------------------------"");
    obj.countDupChars(""BeginnersBook.com"");
  
    System.out.println(""\nString: ChaitanyaSingh"");
    System.out.println(""-------------------------"");
    obj.countDupChars(""ChaitanyaSingh"");
 
    System.out.println(""\nString: #@$@!#$%!!%@"");
    System.out.println(""-------------------------"");
    obj.countDupChars(""#@$@!#$%!!%@"");
  }";0;;
"    @SuppressWarnings(""try"")
    private void doRun(Map<Method, CEntryPointData> entryPoints, Method mainEntryPoint,
                    JavaMainSupport javaMainSupport, String imageName, AbstractBootImage.NativeImageKind k,
                    SubstitutionProcessor harnessSubstitutions,
                    ForkJoinPool compilationExecutor, ForkJoinPool analysisExecutor) {
        List<HostedMethod> hostedEntryPoints = new ArrayList<>();


        OptionValues options = HostedOptionValues.singleton();
        SnippetReflectionProvider originalSnippetReflection = GraalAccess.getOriginalSnippetReflection();
        try (DebugContext debug = DebugContext.create(options, new GraalDebugHandlersFactory(originalSnippetReflection))) {
            setupNativeImage(imageName, options, entryPoints, javaMainSupport, harnessSubstitutions, analysisExecutor, originalSnippetReflection, debug);


            boolean returnAfterAnalysis = runPointsToAnalysis(imageName, options, debug);
            if (returnAfterAnalysis) {
                return;
            }


            NativeImageHeap heap;
            HostedMethod mainEntryPointHostedStub;
            HostedMetaAccess hMetaAccess;
            SharedRuntimeConfigurationBuilder runtime;
            try (StopTimer t = new Timer(imageName, ""universe"").start()) {
                hUniverse = new HostedUniverse(bigbang);
                hMetaAccess = new HostedMetaAccess(hUniverse, bigbang.getMetaAccess());


                new UniverseBuilder(aUniverse, bigbang.getMetaAccess(), hUniverse, hMetaAccess, HostedConfiguration.instance().createStaticAnalysisResultsBuilder(bigbang, hUniverse),
                                bigbang.getUnsupportedFeatures()).build(debug);


                runtime = new HostedRuntimeConfigurationBuilder(options, bigbang.getHostVM(), hUniverse, hMetaAccess, bigbang.getProviders()).build();
                registerGraphBuilderPlugins(featureHandler, runtime.getRuntimeConfig(), (HostedProviders) runtime.getRuntimeConfig().getProviders(), bigbang.getMetaAccess(), aUniverse,
                                hMetaAccess, hUniverse,
                                nativeLibraries, loader, false, true, bigbang.getAnnotationSubstitutionProcessor(), new SubstrateClassInitializationPlugin((SVMHost) aUniverse.hostVM()),
                                bigbang.getHostVM().getClassInitializationSupport());


                if (NativeImageOptions.PrintUniverse.getValue()) {
                    printTypes();
                }


                /* Find the entry point methods in the hosted world. */
                for (AnalysisMethod m : aUniverse.getMethods()) {
                    if (m.isEntryPoint()) {
                        HostedMethod found = hUniverse.lookup(m);
                        assert found != null;
                        hostedEntryPoints.add(found);
                    }
                }
                /* Find main entry point */
                if (mainEntryPoint != null) {
                    AnalysisMethod analysisStub = CEntryPointCallStubSupport.singleton().getStubForMethod(mainEntryPoint);
                    mainEntryPointHostedStub = (HostedMethod) hMetaAccess.getUniverse().lookup(analysisStub);
                    assert hostedEntryPoints.contains(mainEntryPointHostedStub);
                } else {
                    mainEntryPointHostedStub = null;
                }
                if (hostedEntryPoints.size() == 0) {
                    throw UserError.abort(""Warning: no entry points found, i.e., no method annotated with @"" + CEntryPoint.class.getSimpleName());
                }


                heap = new NativeImageHeap(aUniverse, hUniverse, hMetaAccess);


                BeforeCompilationAccessImpl config = new BeforeCompilationAccessImpl(featureHandler, loader, aUniverse, hUniverse, hMetaAccess, heap, debug);
                featureHandler.forEachFeature(feature -> feature.beforeCompilation(config));


                bigbang.getUnsupportedFeatures().report(bigbang);
            } catch (UnsupportedFeatureException ufe) {
                throw UserError.abort(ufe.getMessage());
            }


            recordMethodsWithStackValues();
            recordRestrictHeapAccessCallees(aUniverse.getMethods());


            /*
             * After this point, all TypeFlow (and therefore also TypeState) objects are unreachable
             * and can be garbage collected. This is important to keep the overall memory footprint
             * low. However, this also means we no longer have complete call chain information. Only
             * the summarized information stored in the StaticAnalysisResult objects is available
             * after this point.
             */
            bigbang.cleanupAfterAnalysis();


            NativeImageCodeCache codeCache;
            CompileQueue compileQueue;
            try (StopTimer t = new Timer(imageName, ""compile"").start()) {
                compileQueue = HostedConfiguration.instance().createCompileQueue(debug, featureHandler, hUniverse, runtime, DeoptTester.enabled(), bigbang.getProviders().getSnippetReflection(),
                                compilationExecutor);
                compileQueue.finish(debug);


                /* release memory taken by graphs for the image writing */
                hUniverse.getMethods().forEach(HostedMethod::clear);


                codeCache = NativeImageCodeCacheFactory.get().newCodeCache(compileQueue, heap);
                codeCache.layoutConstants();
                codeCache.layoutMethods(debug, imageName);


                AfterCompilationAccessImpl config = new AfterCompilationAccessImpl(featureHandler, loader, aUniverse, hUniverse, hMetaAccess, heap, debug);
                featureHandler.forEachFeature(feature -> feature.afterCompilation(config));
            }


            try (Indent indent = debug.logAndIndent(""create native image"")) {
                try (DebugContext.Scope buildScope = debug.scope(""CreateBootImage"")) {
                    try (StopTimer t = new Timer(imageName, ""image"").start()) {


                        // Start building the model of the native image heap.
                        heap.addInitialObjects();
                        // Then build the model of the code cache, which can
                        // add objects to the native image heap.
                        codeCache.addConstantsToHeap();
                        // Finish building the model of the native image heap.
                        heap.addTrailingObjects();


                        AfterHeapLayoutAccessImpl config = new AfterHeapLayoutAccessImpl(featureHandler, loader, hMetaAccess, debug);
                        featureHandler.forEachFeature(feature -> feature.afterHeapLayout(config));


                        this.image = AbstractBootImage.create(k, hUniverse, hMetaAccess, nativeLibraries, heap, codeCache, hostedEntryPoints, mainEntryPointHostedStub, loader.getClassLoader());
                        image.build(debug);
                        if (NativeImageOptions.PrintUniverse.getValue()) {
                            /*
                             * This debug output must be printed _after_ and not _during_ image
                             * building, because it adds some PrintStream objects to static fields,
                             * which disrupts the heap.
                             */
                            codeCache.printCompilationResults();
                        }
                    }
                }
            }


            BeforeImageWriteAccessImpl beforeConfig = new BeforeImageWriteAccessImpl(featureHandler, loader, imageName, image,
                            runtime.getRuntimeConfig(), aUniverse, hUniverse, optionProvider, hMetaAccess, debug);
            featureHandler.forEachFeature(feature -> feature.beforeImageWrite(beforeConfig));


            try (StopTimer t = new Timer(imageName, ""write"").start()) {
                /*
                 * This will write the debug info too -- i.e. we may be writing more than one file,
                 * if the debug info is in a separate file. We need to push writing the file to the
                 * image implementation, because whether the debug info and image share a file or
                 * not is an implementation detail of the image.
                 */
                Path tmpDir = tempDirectory();
                Path imagePath = image.write(debug, generatedFiles(HostedOptionValues.singleton()), tmpDir, imageName, beforeConfig).getOutputFile();


                AfterImageWriteAccessImpl afterConfig = new AfterImageWriteAccessImpl(featureHandler, loader, hUniverse, imagePath, tmpDir, image.getBootImageKind(), debug);
                featureHandler.forEachFeature(feature -> feature.afterImageWrite(afterConfig));
            }
        }
    }";1;;https://github.com/oracle/graal/blob/4deb681aaaa79c248115037fc8e399c9876619fd/substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/NativeImageGenerator.java/#L487-L632
"private static void clearSystemPropertiesForImage() {
        System.clearProperty(ImageInfo.PROPERTY_IMAGE_CODE_KEY);
        System.clearProperty(ImageInfo.PROPERTY_IMAGE_KIND_KEY);
    }";0;;
"private static void setSystemPropertiesForImage(NativeImageKind imageKind) {
        System.setProperty(ImageInfo.PROPERTY_IMAGE_CODE_KEY, ImageInfo.PROPERTY_IMAGE_CODE_VALUE_BUILDTIME);
        if (imageKind.executable) {
            System.setProperty(ImageInfo.PROPERTY_IMAGE_KIND_KEY, ImageInfo.PROPERTY_IMAGE_KIND_VALUE_EXECUTABLE);
        } else {
            System.setProperty(ImageInfo.PROPERTY_IMAGE_KIND_KEY, ImageInfo.PROPERTY_IMAGE_KIND_VALUE_SHARED_LIBRARY);
        }
    }";0;;
"private void recordMethodsWithStackValues() {
        bigbang.getUniverse().getMethods().parallelStream().forEach(analysisMethod -> {
            if (analysisMethod.getTypeFlow() != null && analysisMethod.getTypeFlow().getGraph() != null && analysisMethod.getTypeFlow().getGraph().getNodes(StackValueNode.TYPE).isNotEmpty()) {
                hUniverse.recordMethodWithStackValues(analysisMethod);
            }
        });
    }";0;;
"private static boolean addAssertionLIRPhases(LIRSuites lirSuites, boolean hosted) {
        if (hosted) {
            lirSuites.getPostAllocationOptimizationStage().appendPhase(new VerifyDeoptFrameStatesLIRPhase());
        }
        return true;
    }";0;;
"private static <T extends Enum<T>> Set<T> parseCSVtoEnum(Class<T> enumType, String[] csvEnumValues) {
        EnumSet<T> result = EnumSet.noneOf(enumType);
        for (String enumValue : OptionUtils.flatten("","", csvEnumValues)) {
            try {
                result.add(Enum.valueOf(enumType, enumValue));
            } catch (IllegalArgumentException iae) {
                throw VMError.shouldNotReachHere(""Value '"" + enumValue + ""' does not exist. Available values are:\n"" + Arrays.toString(AMD64.CPUFeature.values()));
            }
        }
        return result;
    }";0;;
"    @Override
    public ListenableFuture<Void> recover(QueueManagingVirtualHost<?> virtualHost)
    {
        EventLogger eventLogger = virtualHost.getEventLogger();
        MessageStore store = virtualHost.getMessageStore();
        MessageStore.MessageStoreReader storeReader = store.newMessageStoreReader();
        MessageStoreLogSubject logSubject = new MessageStoreLogSubject(virtualHost.getName(), store.getClass().getSimpleName());


        Map<Queue<?>, Integer> queueRecoveries = new TreeMap<>();
        Map<Long, ServerMessage<?>> recoveredMessages = new HashMap<>();
        Map<Long, StoredMessage<?>> unusedMessages = new TreeMap<>();
        Map<UUID, Integer> unknownQueuesWithMessages = new HashMap<>();
        Map<Queue<?>, Integer> queuesWithUnknownMessages = new HashMap<>();


        eventLogger.message(logSubject, MessageStoreMessages.RECOVERY_START());


        storeReader.visitMessages(new MessageVisitor(recoveredMessages, unusedMessages));


        eventLogger.message(logSubject, TransactionLogMessages.RECOVERY_START(null, false));
        try
        {
            storeReader.visitMessageInstances(new MessageInstanceVisitor(virtualHost,
                                                                         store,
                                                                         queueRecoveries,
                                                                         recoveredMessages,
                                                                         unusedMessages,
                                                                         unknownQueuesWithMessages,
                                                                         queuesWithUnknownMessages));
        }
        finally
        {
            if (!unknownQueuesWithMessages.isEmpty())
            {
                unknownQueuesWithMessages.forEach((queueId, count) -> {
                    LOGGER.info(""Discarded {} entry(s) associated with queue id '{}' as a queue with this ""
                                 + ""id does not appear in the configuration."",
                                 count, queueId);
                });
            }
            if (!queuesWithUnknownMessages.isEmpty())
            {
                queuesWithUnknownMessages.forEach((queue, count) -> {
                    LOGGER.info(""Discarded {} entry(s) associated with queue '{}' as the referenced message ""
                                 + ""does not exist."",
                                 count, queue.getName());
                });
            }
        }


        for(Map.Entry<Queue<?>, Integer> entry : queueRecoveries.entrySet())
        {
            Queue<?> queue = entry.getKey();
            Integer deliveredCount = entry.getValue();
            eventLogger.message(logSubject, TransactionLogMessages.RECOVERED(deliveredCount, queue.getName()));
            eventLogger.message(logSubject, TransactionLogMessages.RECOVERY_COMPLETE(queue.getName(), true));
            queue.completeRecovery();
        }


        for (Queue<?> q : virtualHost.getChildren(Queue.class))
        {
            if (!queueRecoveries.containsKey(q))
            {
                q.completeRecovery();
            }
        }


        storeReader.visitDistributedTransactions(new DistributedTransactionVisitor(virtualHost,
                                                                                   eventLogger,
                                                                                   logSubject, recoveredMessages, unusedMessages));


        for(StoredMessage<?> m : unusedMessages.values())
        {
            LOGGER.debug(""Message id '{}' is orphaned, removing"", m.getMessageNumber());
            m.remove();
        }


        if (unusedMessages.size() > 0)
        {
            LOGGER.info(""Discarded {} orphaned message(s)."", unusedMessages.size());
        }


        eventLogger.message(logSubject, TransactionLogMessages.RECOVERY_COMPLETE(null, false));


        eventLogger.message(logSubject,
                             MessageStoreMessages.RECOVERED(recoveredMessages.size() - unusedMessages.size()));
        eventLogger.message(logSubject, MessageStoreMessages.RECOVERY_COMPLETE());


        return Futures.immediateFuture(null);
    }";1;;
"    private NameRegion[] findLinkComponentsInClosure(ClosureExpression firstArg,
            int offset) {
        if (! (firstArg.getCode() instanceof BlockStatement)) {
            return null;
        }
        
        BlockStatement code = (BlockStatement) firstArg.getCode();
        if (code.getStatements() == null) {
            return null;
        }
        NameRegion controllerName = null;
        NameRegion actionName = null;
        NameRegion viewName = null;


        for (Statement state : code.getStatements()) {
            if (state instanceof ExpressionStatement) {
                if (((ExpressionStatement) state).getExpression() instanceof BinaryExpression) {
                    BinaryExpression bexpr = (BinaryExpression) ((ExpressionStatement) state).getExpression();
                    Expression left = bexpr.getLeftExpression();
                    if (bexpr.getOperation().getText().equals(""="") && left instanceof VariableExpression) {
                        Expression right = bexpr.getRightExpression();
                        Region region;
                        if (right.getStart() <= offset && right.getEnd() >= offset) {
                            region = new Region(right.getStart(), right.getLength());
                        } else {
                            region = null;
                        }


                        String name = left.getText();
                        if (name.equals(""controller"")) {
                            controllerName = new NameRegion(right.getText(), region);
                        } else if (name.equals(""action"")) {
                            actionName = new NameRegion(right.getText(), region);
                        } else if (name.equals(""view"")) {
                            viewName = new NameRegion(right.getText(), region);
                        }
                    }
                }
            }
        }
        return new NameRegion[] { controllerName, actionName, viewName };
    }";1;;
"private IType findController(String controllerName, IJavaProject project) {
        try {
            return GrailsWorkspaceCore.get().create(project).findControllerFromSimpleName(controllerName);
        } catch (JavaModelException e) {
            GrailsCoreActivator.log(e);
        }
        return null;
    }";0;;
"  private EntityCollection createETStreamOnComplexProp(Edm edm, OData odata) {
    EntityCollection entityCollection = new EntityCollection();


    Link readLink = new Link();
    readLink.setRel(Constants.NS_MEDIA_READ_LINK_REL);
    readLink.setHref(""readLink"");
    Entity entity = new Entity();
    entity.addProperty(createPrimitive(""PropertyStream"", createImage(""darkturquoise"")));
    readLink.setInlineEntity(entity);
    
    Link readLink1 = new Link();
    readLink1.setRel(Constants.NS_MEDIA_READ_LINK_REL);
    readLink1.setHref(""readLink"");
    entity = new Entity();
    entity.addProperty(createPrimitive(""PropertyEntityStream"", createImage(""darkturquoise"")));
    readLink1.setInlineEntity(entity);
    
    entityCollection.getEntities().add(new Entity()
        .addProperty(createPrimitive(""PropertyInt16"", Short.MAX_VALUE))
        .addProperty(createPrimitive(""PropertyInt32"", Integer.MAX_VALUE))
        .addProperty(new Property(null, ""PropertyEntityStream"", ValueType.PRIMITIVE, readLink1))
        .addProperty(createComplex(""PropertyCompWithStream"",
            ComplexTypeProvider.nameCTWithStreamProp.getFullQualifiedNameAsString(),
            new Property(null, ""PropertyStream"", ValueType.PRIMITIVE, readLink),
            createComplex(""PropertyComp"", 
                ComplexTypeProvider.nameCTTwoPrim.getFullQualifiedNameAsString(),
                createPrimitive(""PropertyInt16"", (short) 333),
                createPrimitive(""PropertyString"", ""TEST123"")))));
    
    Link editLink = new Link();
    editLink.setRel(Constants.NS_MEDIA_EDIT_LINK_REL);
    editLink.setHref(""http://mediaserver:1234/editLink"");
    editLink.setMediaETag(""eTag"");
    editLink.setType(""image/jpeg"");
    entity = new Entity();
    entity.addProperty(createPrimitive(""PropertyStream"", createImage(""royalblue"")));
    editLink.setInlineEntity(entity);
    
    Link editLink2 = new Link();
    editLink2.setRel(Constants.NS_MEDIA_EDIT_LINK_REL);
    editLink2.setHref(""http://mediaserver:1234/editLink"");
    editLink2.setMediaETag(""eTag"");
    editLink2.setType(""image/jpeg"");
    entity = new Entity();
    entity.addProperty(createPrimitive(""PropertyEntityStream"", createImage(""royalblue"")));
    editLink2.setInlineEntity(entity);


    entityCollection.getEntities().add(new Entity()
        .addProperty(createPrimitive(""PropertyInt16"", (short) 7))
        .addProperty(createPrimitive(""PropertyInt32"", (Integer) 10))
        .addProperty(new Property(null, ""PropertyEntityStream"", ValueType.PRIMITIVE, editLink2))
        .addProperty(createComplex(""PropertyCompWithStream"",
            ComplexTypeProvider.nameCTWithStreamProp.getFullQualifiedNameAsString(),
            new Property(null, ""PropertyStream"", ValueType.PRIMITIVE, editLink),
            createComplex(""PropertyComp"", 
                ComplexTypeProvider.nameCTTwoPrim.getFullQualifiedNameAsString(),
                createPrimitive(""PropertyInt16"", (short) 333),
                createPrimitive(""PropertyString"", ""TEST123"")))));


    setEntityType(entityCollection, edm.getEntityType(EntityTypeProvider.nameETStreamOnComplexProp));
    createEntityId(edm, odata, ""ESStreamOnComplexProp"", entityCollection);
    createOperations(""ESStreamOnComplexProp"", entityCollection, EntityTypeProvider.nameETStreamOnComplexProp);
    return entityCollection;
  }";1;;
